# [10, 8, 3, 5, 2, 4, 11, 18, 20, 33]のような配列を昇順に並べ変えてください。
# 標準関数のsortやsort_byは使わないことを条件とします。
# ソートアルゴリズムは「バブルソート」を採用してください。



numbers = [10, 8, 3, 5, 2, 4, 11, 18, 20, 33]
how_much = numbers.size - 1

(0...how_much).each do |x|
    (0...(how_much - x)).each do |xx|
        y = xx + 1
        if numbers[xx] > numbers[y]
            numbers[xx], numbers[y] = numbers[y], numbers[xx]
        end
    end
end

puts numbers


# （0から配列の数ー１した数）だけ比較を繰り返そう b/c 自分自身を抜かないといけないから。
# 大枠で囲わないと一回すべての要素と比べただけで処理が終了した。今回だと10だけが移動していた。
# 今回の繰り返し処理は１つの要素を他の全ての要素と比べる繰り返しとその動作自体を要素を変えて繰り返す二重構造になっている。
# (0...how_much).each do |x|ここのｘは繰り返し回数（今回なら８回）を受けているわけではなく段階ごとに値を返している。
# 最初は０、次は１、２という感じに。だから二十繰り返し部分でhow_much - xをすることで繰り返しの被りを省略することができる。
#（配列の数ー１回）配列の要素をそれぞれ比べる
# 自分より数値が大きければ順番をその数値と位置を入れ替える
# 配列から要素を取得するためには以下のように
# 配列名[要素の番号を指定する]
# drinks = ["coffee", "latte"]
# puts drinks[0]
# puts drinks[1]
# つまり、今回のように１つの要素と隣の要素を比べたい場合は
# 比べる要素 = x 比べられる隣の要素(y) = x + 1, として
# if drinks[x] > drinks[y]
#     drinks[x],drinks[y] = drinks[y],drinks[x]
# end
# と書くことで並び替えを行うことができる。






